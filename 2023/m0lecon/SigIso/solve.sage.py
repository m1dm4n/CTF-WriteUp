

# This file was *autogenerated* from the file solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_8888 = Integer(8888); _sage_const_3 = Integer(3); _sage_const_117 = Integer(117); _sage_const_4 = Integer(4); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_30 = Integer(30); _sage_const_5 = Integer(5); _sage_const_2 = Integer(2); _sage_const_6 = Integer(6); _sage_const_10 = Integer(10)
from pwn import remote, success, process
from json import loads, dumps
from hashlib import sha256
from itertools import product
import re
import string
import random
io = remote('sigiso.challs.m0lecon.it', int(_sage_const_8888 ))
# io = process(['sage', 'server.sage'])
ls = list(prime_range(_sage_const_3 , _sage_const_117 ))
p = _sage_const_4  * prod(ls) - _sage_const_1 
F = GF(p)
base = _sage_const_0 
N = len(ls)
T = _sage_const_30 
B = _sage_const_5 

R = GF(p)['t']; (t,) = R._first_ngens(1)
def montgomery_coefficient(E):
    a, b = E.short_weierstrass_model().a_invariants()[-_sage_const_2 :]
    r, = (t**_sage_const_3  + a*t + b).roots(multiplicities=False)
    s = sqrt(_sage_const_3 *r**_sage_const_2  + a)
    return -_sage_const_3  * (-_sage_const_1 )**is_square(s) * r / s


def csidh(pub, priv):
    E = EllipticCurve(F, [_sage_const_0 , int(pub), _sage_const_0 , _sage_const_1 , _sage_const_0 ])
    for es in ([max(_sage_const_0 , +e) for e in priv], [max(_sage_const_0 , -e) for e in priv]):
        while any(es):
            P = E.random_element()
            k = prod(l for l, e in zip(ls, es) if e)
            P *= (p+_sage_const_1 ) // k
            for i, (l, e) in enumerate(zip(ls, es)):
                if not e:
                    continue
                k //= l
                Q = k*P
                if Q == _sage_const_0 :
                    continue
                phi = E.isogeny(Q)
                E, P = phi.codomain(), phi(P)
                es[i] -= _sage_const_1 
        E = E.quadratic_twist()
    return int(montgomery_coefficient(E))
def sub(a, b):
    return [x-y for x, y in zip(a, b)]


def sign(msg, sk):
    fs = []
    Es = []
    for i in range(T):
        f = [random.randint(-B, B) for _ in range(N)]
        E = csidh(base, f)
        fs.append(f)
        Es.append(E)
    s = ",".join(map(str, Es)) + "," + msg
    h = int.from_bytes(sha256(s.encode()).digest(), "big")
    outs = []
    for i in range(T):
        b = (h >> i) & _sage_const_1 
        if b:
            outs.append(
                {"bit": int(b), "vec": [int(x) for x in sub(fs[i], sk)]})
        else:
            outs.append({"bit": int(b), "vec": [int(x) for x in fs[i]]})
    return outs
def solve_pow(io):
    pow_re = re.compile(b"starting in (.*) such that its sha256sum ends in (.*)\.")
    prefix, goal = pow_re.findall(io.recvline(_sage_const_0 ))[_sage_const_0 ]
    goal = goal.decode()
    for s in product((string.ascii_letters + string.digits).encode(), repeat=_sage_const_6 ):
        if sha256(prefix + bytes(s)).hexdigest()[-len(goal):] == goal:
            io.sendline(prefix + bytes(s))
            success("PoW done!")
            break
solve_pow(io)
# print(io.recvline())

pub = int(io.recvline(_sage_const_0 ).split(b': ')[-_sage_const_1 ])

def Choose(n: int):
    io.sendlineafter(b"> ", str(n).encode())

def get_sign():
    Choose(_sage_const_1 )
    io.sendlineafter(b"?\n", b"lmao")
    res = loads(io.recvline(_sage_const_0 ))
    return res['signature']

C = [set() for i in range(N)]

while True:
    pays = get_sign()
    for pay in pays:
        bit = pay['bit']
        if bit == _sage_const_0 :
            continue
        vec = pay['vec']
        for i, j in enumerate(vec):
            C[i].add(j)
    print([max(c) - min(c) for c in C])
    if all(max(c) - min(c) >= _sage_const_10  for c in C):
        break
priv = [int(_sage_const_5  - max(c)) for c in C]
print(priv)
print(csidh(base, priv)) 
print(pub)

msg = "gimmetheflag"
sig = sign(msg, priv)


Choose(_sage_const_2 )
io.sendlineafter(b"\n", dumps({"msg": msg, "signature": sig}).encode())
io.interactive()

